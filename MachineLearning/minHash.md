#利用Minhash和LSH寻找相似的集合

##背景
给出N个集合，找到相似的集合对，如何实现呢？

##思路
将大体上相似的集合聚到一起，缩小比对的范围，这样只用检测较少的集合对，就可以找到绝大多数相似的集合对，大幅度减少时间开销。

接下来的内容讲解如何使用Minhash和LSH（Locality-sensitive Hashing）来实现上述目的，在相似的集合较少的情况下，可以在O(n)时间找到大部分相似的集合对。

##Jaccard相似度
![image](/Users/chenjiawei/Screencapture/屏幕快照 2014-12-04 下午1.07.54.png
)

##MinHash
采用一种hash函数，将元素的位置均匀打乱，然后将新顺序下每个集合第一个元素作为该集合的特征值。

我们有如下结论
![image](/Users/chenjiawei/Screencapture/屏幕快照 2014-12-04 下午2.21.17.png
)

也即，两个集合的minhash值相等的概率等于两个集合的Jaccard相似度。

**minhash的最终结果是引入一系列的hash函数，将原向量变换为一系列hash函数的minhash值**。

**可以证明**，Minhash在压缩原始集合的情况下，保证了集合的相似度没有被破坏。

##LSH（Local sensitive hash）
现在有了原始集合的摘要，但是还是没有解决最初的问题，仍然需要遍历所有的集合对,，才能所有相似的集合对，复杂度仍然是$O(n^2)$。所以，接下来描述解决这个问题的核心思想LSH。

其基本思路是将相似的集合聚集到一起，减小查找范围，避免比较不相似的集合。

1. 将minhash向量分为B组，每组有C个值。
2. 为每一组部分向量引入一个hash函数，对应于一个hash表，共B个。
3. 对于每个向量，以每一组的部分向量为hash函数的输入，映射到对应的hash表中，复杂度O(n)。
4. 最后遍历B个hash表，将每一对发生碰撞的pair选出来，作为可能的相似对。


![image](/Users/chenjiawei/Screencapture/屏幕快照 2014-12-04 下午4.45.56.png
)

通过简单的对立事件可以推得以上关系。

其中，r = Jaccord(A|B), C为每个区间的向量数，B为区间数。

如我们希望筛选出相似度r的向量pair，我们需要选择合适的B和C，使得以上概率值接近1，也即至少有一个区间会发生碰撞。因此一旦发生碰撞的，一定是相似度大于r的。











